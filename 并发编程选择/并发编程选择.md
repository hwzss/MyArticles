## GCD or NSThread

> 一直以来使用 GCD 进行并发编程 而不是使用 NSThread 进行线程编程，只是因为 GCD 方便的 API 设计，却并没有仔细想想为什么 NO NSThread?
> 
> 备注: 并发编程更注重于任务的并发，忽略线程的管理；而线程编程则应该是两者兼具吧。

### GCD
在官方文档介绍里，一直推荐的是使用GCD来进行并发编程，而不是使用NSThread来进行线程编程。原因有下：

1. GCD提供方便的Api，让我们在进行并发编程时只要关注具体的任务，而无需关注多余的线程管理；
2. GCD帮我们提供了线程管理，我们不需要自己创建、销毁线程，同时通过GCD来进行并发编程，系统能够更好的利用线程资源，众所周知线程资源时有限的，在有限的资源下，GCD能更好的发挥多线程的作用；
3. 通过GCD来进行资源的同步读取来代替锁操作，相对线程锁来说，在某种情况下会更好，具体文档没说明，但却指出了，GCD代替锁可以减少锁每次的解锁操作都进入系统内核状态，这也是一种资源节省，优化；


### NSThread ?
苹果不推荐NSThread原因有下：

1. 线程比较占用内存(用户内存以及内核内存)，如果不是很熟悉线程编程，容易导致资源的浪费；
2. 如果执行一个短的任务，线程一般执行完就退出了，这时将任务交给GCD，也许GCD会将创建的线程进行重用，避免多余的创建(不管现在有没有重用功能，这都是可以优化的)；
3. 如果自己创建线程来执行一个长任务，使用GCD一样能完成，而且少了线程创建任务；
4. 如果实现一个类似于AFN那样，线程保活，然后不断的执行一些任务呢？ 不好意思，还是不推荐NSThread, 如果你创建一个线程，并且通过Runloop进行保活，但却不能保证该线程一直是满载进行任务操作，这仍然是一种资源浪费，使用GCD一样能实现这种效果，而且还不会浪费资源， 可见新版的AFN已经使用GCD来替代原来的NSThread保活，所以不要在线程保活保活了，不能满载的情况下就是资源浪费。


### 相关资料




